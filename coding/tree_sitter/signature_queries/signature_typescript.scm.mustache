; get symbol name from signature
(ERROR
	(identifier) @class.name
)

; only top-level function signatures (not inside ambient_declaration)
(program
  (function_signature
    name: (identifier) @function.name
    type_parameters: (_)? @function.type_parameters
    parameters: (formal_parameters) @function.parameters
    return_type: (_)? @function.return_type
  ) @function.declaration
)
(function_expression
  name: (identifier) @function.name
  type_parameters: (_)? @function.type_parameters
  parameters: (formal_parameters) @function.parameters
  return_type: (_)? @function.return_type
) @function.declaration

(function_declaration
  name: (identifier) @function.name
  type_parameters: (_)? @function.type_parameters
  parameters: (formal_parameters) @function.parameters
  return_type: (_)? @function.return_type
) @function.declaration

(generator_function_declaration
  name: (identifier) @function.name
  type_parameters: (_)? @function.type_parameters
  parameters: (formal_parameters) @function.parameters
  return_type: (_)? @function.return_type
) @function.declaration

(ambient_declaration
  (function_signature
    name: (identifier) @function.name
    type_parameters: (_)? @function.type_parameters
    parameters: (formal_parameters) @function.parameters
    return_type: (_)? @function.return_type
  )
) @function.declaration

(interface_declaration
  name: (_) @interface.name
) @interface.declaration

(type_alias_declaration
  name: (_) @type_alias.name
) @type_alias.declaration

(enum_declaration
  name: (identifier) @enum.name
) @enum.declaration

(enum_declaration
  body: (enum_body
    name: (_)? @enum_member.name
    (enum_assignment
      name: (_)? @enum_member.name
    )*
  )
)

; only top-level lexical declarations are included in signatures
(program
  (lexical_declaration
    (variable_declarator
      name: (identifier) @lexical.name
    )
  ) @lexical.declaration
)

; only top-level variable declarations are included in signatures
(program
  (variable_declaration
    (variable_declarator
      name: (identifier) @var.name
    )
  ) @var.declaration
)

; node type can be class_declaration or just class
(_
  name: (_) @class.name
  (class_heritage)* @class.heritage
  (class_body
    [
      (public_field_definition
        (accessibility_modifier)* @class.field.mod
        name: (_) @class.field.name
        type: (_)? @class.field.type
      ) @class.field.declaration

      (method_definition
        (accessibility_modifier)* @class.method.mod
        name: (_) @class.method.name
        parameters: (_) @class.method.parameters
        return_type: (_)? @class.method.return_type
        body: (_) @class.method.body
      ) @class.method.declaration

      (abstract_method_signature
        "abstract" @class.method.mod
        name: (_) @class.method.name
        parameters: (_) @class.method.parameters
        return_type: (_)? @class.method.return_type
      ) @class.method.declaration

      (_)

      ";"
    ]*
  ) @class.body
) @class.declaration

; for symbol outline
(method_definition
  name: (_) @method.name
)

; TODO
;(function_signature
;  name: (identifier) @function.name
;  parameters: (formal_parameters) @function.parameters
;  return_type: (type_annotation) @function.return_type
;)
;
;(method_signature
;  name: (property_identifier) @method.name)
;
;(abstract_method_signature
;  name: (property_identifier) @abstract_method_signature.name)
;
;(abstract_class_declaration
;  name: (type_identifier) @abstract_class.name) @abstract_class.declaration
;
;(module
;  name: (identifier) @module.name) @module.declaration
;